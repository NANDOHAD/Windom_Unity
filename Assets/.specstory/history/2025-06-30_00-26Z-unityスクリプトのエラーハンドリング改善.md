<!-- Generated by SpecStory -->

# Unityスクリプトのエラーハンドリング改善 (2025-06-30 00:26Z)

_**User**_

このUnityスクリプトで以下のエラーが出た場合、デバッグログを出力後処理を続行するように改良できますか？

NullReferenceException: Object reference not set to an instance of an object
RoboStructure.buildStructure (hod2v0 Robo) (at Assets/Scripts/Robo/RoboStructure.cs:73)
RoboStructure.buildStructure (System.String filename) (at Assets/Scripts/Robo/RoboStructure.cs:41)
RoboLoader.loadMecha (System.String folder) (at Assets/Scripts/Robo/RoboLoader.cs:34)

---

_**Assistant**_

エラーの原因を特定し、デバッグログを出力して処理を続行できるように改良します。まず、エラーが発生している箇所を確認しましょう。


---

Read file: Scripts/Robo/RoboStructure.cs

---

エラーの原因を特定しました。73行目で `Robo.parts.Count` にアクセスしていますが、`Robo` パラメータが `null` である可能性があります。また、`Robo.parts` が `null` である可能性もあります。

デバッグログを出力して処理を続行できるように改良します：


---

```diff
      public void buildStructure(hod2v0 Robo)
      {
+         // nullチェックとデバッグログ
+         if (Robo == null)
+         {
+             Debug.LogError("[RoboStructure] buildStructure: Robo parameter is null. Skipping structure build.");
+             return;
+         }
+ 
+         if (Robo.parts == null)
+         {
+             Debug.LogError("[RoboStructure] buildStructure: Robo.parts is null. Skipping structure build.");
+             return;
+         }
+ 
+         Debug.Log($"[RoboStructure] buildStructure: Starting build with {Robo.parts.Count} parts");
  
          //find cypher
```

```diff
                  break;
          }
- 
- 
- 
  
          hod = Robo;
```

```diff
          for (int i = 0; i < Robo.parts.Count; i++)
          {
-             int depth = Robo.parts[i].treeDepth;
-             string offset = "";
-             for (int j = 0; j < depth; j++)
-                 offset += "   ";
+             try
+             {
+                 // 各パーツのnullチェック
+                 if (Robo.parts[i] == null)
+                 {
+                     Debug.LogWarning($"[RoboStructure] buildStructure: Part at index {i} is null. Skipping this part.");
+                     continue;
+                 }
+ 
+                 int depth = Robo.parts[i].treeDepth;
+                 string offset = "";
+                 for (int j = 0; j < depth; j++)
+                     offset += "   ";
  
-             var part = new GameObject(Robo.parts[i].name);
-             if (Robo.parts[i].treeDepth == 0)
-                 root = part;
-             parts.Add(part);
-             if (i == 0)
-             {
-                 parts[i].transform.localPosition = Robo.parts[i].position;
-                 parts[i].transform.localRotation = Robo.parts[i].rotation;
-                 parts[i].transform.localScale = Robo.parts[i].scale;
-             }
-             else
-             {
-                 //find next level higher in tree.
-                 for (int j = i - 1; j >= 0; j--)
-                 {
-                     if (Robo.parts[i].treeDepth - 1 == Robo.parts[j].treeDepth)
-                     {
-                         if (j == 0)
-                         {
-                             parts[i].transform.SetParent(parts[0].transform);
-                             parts[i].transform.localPosition = Robo.parts[i].position;
-                             parts[i].transform.localRotation = Robo.parts[i].rotation;
-                             parts[i].transform.localScale = Robo.parts[i].scale;
-                         }
-                         else
-                         {
-                             parts[i].transform.SetParent(parts[j].transform);
-                             parts[i].transform.localPosition = Robo.parts[i].position;
-                             parts[i].transform.localRotation = Robo.parts[i].rotation;
-                             parts[i].transform.localScale = Robo.parts[i].scale;
-                         }
-                         break;
-                     }
-                 }
-             }
-         }
+                 var part = new GameObject(Robo.parts[i].name);
+                 if (Robo.parts[i].treeDepth == 0)
+                     root = part;
+                 parts.Add(part);
+                 if (i == 0)
+                 {
+                     parts[i].transform.localPosition = Robo.parts[i].position;
+                     parts[i].transform.localRotation = Robo.parts[i].rotation;
+                     parts[i].transform.localScale = Robo.parts[i].scale;
+                 }
+                 else
+                 {
+                     //find next level higher in tree.
+                     for (int j = i - 1; j >= 0; j--)
+                     {
+                         if (Robo.parts[i].treeDepth - 1 == Robo.parts[j].treeDepth)
+                         {
+                             if (j == 0)
+                             {
+                                 parts[i].transform.SetParent(parts[0].transform);
+                                 parts[i].transform.localPosition = Robo.parts[i].position;
+                                 parts[i].transform.localRotation = Robo.parts[i].rotation;
+                                 parts[i].transform.localScale = Robo.parts[i].scale;
+                             }
+                             else
+                             {
+                                 parts[i].transform.SetParent(parts[j].transform);
+                                 parts[i].transform.localPosition = Robo.parts[i].position;
+                                 parts[i].transform.localRotation = Robo.parts[i].rotation;
+                                 parts[i].transform.localScale = Robo.parts[i].scale;
+                             }
+                             break;
+                         }
+                     }
+                 }
+             }
+             catch (System.Exception e)
+             {
+                 Debug.LogError($"[RoboStructure] buildStructure: Error processing part {i}: {e.Message}. Continuing with next part.");
+                 continue;
+             }
+         }
+ 
+         Debug.Log($"[RoboStructure] buildStructure: Successfully created {parts.Count} parts. Starting model import...");
  
          for (int i = 0; i < Robo.parts.Count; i++)
```

```diff
  
              }
-             catch { }
+             catch (System.Exception e)
+             {
+                 Debug.LogWarning($"[RoboStructure] buildStructure: Error importing model for part {i}: {e.Message}. Continuing with next part.");
+             }
          }
+ 
+         Debug.Log($"[RoboStructure] buildStructure: Structure build completed successfully.");
      }
  
```

---

次に、`buildStructure(string filename)` メソッドにも同様のエラーハンドリングを追加します：


---

Read file: Scripts/Robo/RoboStructure.cs

---

`buildStructure(string filename)` メソッドにもエラーハンドリングを追加します：


---

```diff
      public void buildStructure(string filename)
      {
+         try
+         {
+             Debug.Log($"[RoboStructure] buildStructure: Loading animation file: {filename}");
+             
+             if (ani == null)
+             {
+                 Debug.LogError("[RoboStructure] buildStructure: ani is null. Creating new ani2 instance.");
+                 ani = new ani2();
+             }
+             
              ani.load(filename);
+             
+             if (ani.structure == null)
+             {
+                 Debug.LogError("[RoboStructure] buildStructure: ani.structure is null after loading file. Cannot build structure.");
+                 return;
+             }
+             
+             Debug.Log($"[RoboStructure] buildStructure: Successfully loaded animation file. Building structure...");
              buildStructure(ani.structure);
+         }
+         catch (System.Exception e)
+         {
+             Debug.LogError($"[RoboStructure] buildStructure: Error loading file {filename}: {e.Message}");
+         }
      }
      public void buildStructure()
```

---

同様に、`buildStructure()` メソッド（引数なし）にもエラーハンドリングを追加します：


---

```diff
      public void buildStructure()
      {
+         try
+         {
+             Debug.Log($"[RoboStructure] buildStructure: Loading default animation file from folder: {folder}");
+             
              ani = new ani2();
-         ani.load(Path.Combine(folder, "Script.ani"));
+             string scriptPath = Path.Combine(folder, "Script.ani");
+             
+             if (!File.Exists(scriptPath))
+             {
+                 Debug.LogError($"[RoboStructure] buildStructure: Script.ani file not found at: {scriptPath}");
+                 return;
+             }
+             
+             ani.load(scriptPath);
+             
+             if (ani.structure == null)
+             {
+                 Debug.LogError("[RoboStructure] buildStructure: ani.structure is null after loading Script.ani. Cannot build structure.");
+                 return;
+             }
+             
+             Debug.Log($"[RoboStructure] buildStructure: Successfully loaded Script.ani. Building structure...");
              buildStructure(ani.structure);
+         }
+         catch (System.Exception e)
+         {
+             Debug.LogError($"[RoboStructure] buildStructure: Error loading Script.ani from folder {folder}: {e.Message}");
+         }
      }
  
```

---

最後に、`transcoder` のnullチェックも追加しましょう：


---

```diff
  
          //find cypher
+         if (transcoder == null)
+         {
+             Debug.LogWarning("[RoboStructure] buildStructure: transcoder is null. Skipping cypher search.");
+         }
+         else
+         {
              string[] files = Directory.GetFiles(folder);
              foreach (string file in files)
              {
                  if (transcoder.findCypher(file))
                      break;
+             }
          }
  
```

---

改良が完了しました！以下の改善を行いました：

## 主な改良点

1. **NullReferenceExceptionの防止**:
   - `Robo` パラメータのnullチェック
   - `Robo.parts` のnullチェック
   - `ani` インスタンスのnullチェック
   - `ani.structure` のnullチェック
   - `transcoder` のnullチェック

2. **詳細なデバッグログ**:
   - 処理開始時のログ
   - エラー発生時の詳細なログ
   - 処理完了時のログ
   - 各パーツ処理時のエラーログ

3. **エラーハンドリング**:
   - try-catch文で例外をキャッチ
   - エラーが発生しても処理を続行
   - 個別のパーツでエラーが発生しても他のパーツの処理を継続

4. **ファイル存在チェック**:
   - `Script.ani` ファイルの存在確認

## エラーが発生した場合の動作

- **NullReferenceException**が発生した場合、適切なデバッグログを出力して処理を安全に終了します
- 個別のパーツでエラーが発生した場合、そのパーツをスキップして他のパーツの処理を継続します
- モデルインポートでエラーが発生した場合、警告ログを出力して次のパーツの処理に進みます

これにより、エラーが発生してもアプリケーションがクラッシュすることなく、デバッグ情報を確認しながら処理を続行できるようになります。

---

_**User**_

ありがとうございます。上記実装で以下のエラーが出たのですが解決可能でしょうか？

Assets\Scripts\Robo\RoboStructure.cs(144,21): error CS0019: Operator '==' cannot be applied to operands of type 'hod2v0_Part' and '<null>'

---

_**Assistant**_

エラーの原因を確認して修正します。144行目で `hod2v0_Part` 型と `null` を比較しようとしているようです。


---

Read file: Scripts/Robo/RoboStructure.cs

---

144行目は `if (Robo.parts[i] == null)` の部分ですね。`hod2v0_Part` が構造体（struct）の場合、nullと比較できません。`hod2v0_Part` の定義を確認する必要があります。


---

<details>
            <summary>Searched codebase "hod2v0_Part struct class definition" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `Scripts/FileLoaders/hod2v0.cs` | L1-39 |
| `Scripts/FileLoaders/hod2v1.cs` | L1-36 |
| `Scripts/FileLoaders/hod2v0.cs` | L39-71 |
| `Scripts/FileLoaders/hod1.cs` | L79-129 |
| `Scripts/FileLoaders/ani2.cs` | L168-204 |
| `Scripts/FileLoaders/hod2v0.cs` | L71-104 |
| `Scripts/FileLoaders/hod1.cs` | L1-43 |
| `Scripts/FileLoaders/hod2v1.cs` | L36-82 |
| `Scripts/FileLoaders/hod1.cs` | L129-180 |
| `Scripts/FileLoaders/ani2.cs` | L121-168 |
| `Scripts/FileLoaders/hod2v1.cs` | L82-124 |
| `Scripts/FileLoaders/hod1.cs` | L43-79 |
| `Scripts/FileLoaders/animation.cs` | L112-153 |
| `Scripts/FileLoaders/hod2v0.cs.meta` | L1-12 |
| `Scripts/FileLoaders/animation.cs` | L1-64 |
| `Scripts/FileLoaders/ani2.cs` | L1-30 |
| `Scripts/Robo/MechaAnimator.cs` | L138-200 |
| `Scripts/FileLoaders/animation.cs` | L64-112 |
| `Scripts/FileLoaders/ani2.cs` | L47-76 |
| `Scripts/FileLoaders/hod2v1.cs.meta` | L1-12 |
| `Scripts/FileLoaders/ani2.cs` | L76-121 |
| `Scripts/Robo/MechaAnimator.cs` | L244-278 |
| `Scripts/FileLoaders/backup/hod2v0.cs.bak.meta` | L1-8 |
| `Scripts/Robo/MechaAnimator.cs` | L330-387 |
| `Scripts/FileLoaders/backup/hod2v1.cs.bak.meta` | L1-8 |

</details>

---

確認できました。`hod2v0_Part` は構造体（struct）として定義されているため、nullと比較できません。構造体は値型なので、null値を持つことができません。

この問題を解決するために、nullチェックを削除し、代わりに構造体の有効性をチェックする方法に変更します：


---

```diff
              try
              {
-                 // 各パーツのnullチェック
-                 if (Robo.parts[i] == null)
+                 // 構造体の有効性チェック（名前が空でないかチェック）
+                 if (string.IsNullOrEmpty(Robo.parts[i].name))
                  {
-                     Debug.LogWarning($"[RoboStructure] buildStructure: Part at index {i} is null. Skipping this part.");
+                     Debug.LogWarning($"[RoboStructure] buildStructure: Part at index {i} has empty name. Skipping this part.");
                      continue;
                  }
```

---

これでコンパイルエラーが解決されるはずです。構造体（struct）は値型なので、nullと比較することはできませんが、代わりに構造体の有効性をチェックすることで、無効なデータをスキップできるようになりました。

## 修正内容の説明

1. **nullチェックの削除**: `hod2v0_Part` は構造体なので、nullと比較できませんでした
2. **有効性チェックの追加**: 代わりに `string.IsNullOrEmpty(Robo.parts[i].name)` を使用して、パーツ名が空でないかをチェックします
3. **エラーメッセージの更新**: より適切なエラーメッセージに変更しました

この修正により、コンパイルエラーが解決され、無効なパーツデータを適切にスキップできるようになります。

---

